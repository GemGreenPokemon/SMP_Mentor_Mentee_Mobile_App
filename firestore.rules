rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function hasRole(role) {
      return isAuthenticated() && request.auth.token.role == role;
    }
    
    function isSuperAdmin() {
      return isAuthenticated() && request.auth.token.role == 'super_admin';
    }
    
    function isInUniversity(universityPath) {
      return isAuthenticated() && (
        (request.auth.token.university_path != null && request.auth.token.university_path == universityPath) ||
        isSuperAdmin() ||  // Super admins can access any university
        hasRole('developer')  // Developers can access any university
      );
    }
    
    // Universities collection - only super admins can manage
    match /universities/{universityId} {
      allow read: if isAuthenticated();
      allow write: if isSuperAdmin();
    }
    
    // University-specific data
    match /{universityPath}/data {
      // Users collection
      match /users/{userId} {
        allow read: if isInUniversity(universityPath) && (
          isOwner(userId) || 
          hasRole('coordinator') || 
          hasRole('developer')
        );
        allow create: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer') ||
          isSuperAdmin()
        );
        allow update: if isInUniversity(universityPath) && (
          isOwner(userId) || 
          hasRole('coordinator') || 
          hasRole('developer')
        );
        allow delete: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        );
        
        // User subcollections - Now excludes meetings, availability, requestedMeetings
        match /{subcollection}/{document} {
          allow read, write: if isInUniversity(universityPath) && 
            isOwner(userId) &&
            subcollection != 'meetings' &&
            subcollection != 'availability' &&
            subcollection != 'requestedMeetings';
        }
      }
      
      // Conversations collection (NEW)
      match /conversations/{conversationId} {
        function isParticipant() {
          return isAuthenticated() && 
                 isInUniversity(universityPath) &&
                 request.auth.uid in resource.data.participants;
        }
        
        function isValidParticipant() {
          return isAuthenticated() && 
                 isInUniversity(universityPath) &&
                 request.auth.uid in request.resource.data.participants;
        }
        
        // Read conversation if participant
        allow read: if isParticipant();
        
        // Create conversation if user is a participant
        allow create: if isValidParticipant()
          && request.resource.data.participants.size() >= 2
          && request.resource.data.keys().hasAll(['participants', 'created_at', 'type']);
        
        // Update only specific fields
        allow update: if isParticipant()
          && !request.resource.data.diff(resource.data).affectedKeys()
            .hasAny(['participants', 'created_at']);
        
        // Don't allow deletion of conversations
        allow delete: if false;
        
        // Messages subcollection
        match /messages/{messageId} {
          allow read: if isParticipant();
          
          allow create: if isParticipant()
            && request.auth.uid == request.resource.data.sender_id
            && request.resource.data.keys().hasAll(['message', 'sender_id', 'sent_at', 'type'])
            && request.resource.data.message is string
            && request.resource.data.message.size() > 0
            && request.resource.data.message.size() < 5000;
          
          // Messages are immutable (no edit/delete)
          allow update: if false;
          allow delete: if false;
        }
        
        // Typing status subcollection
        match /typing_status/{userId} {
          allow read: if isParticipant();
          allow write: if isParticipant() && request.auth.uid == userId;
        }
      }
      
      // Meetings collection (UPDATED for new structure)
      match /meetings/{meetingId} {
        function isMeetingParticipant() {
          return isAuthenticated() && (
            request.auth.uid == resource.data.mentor_uid ||
            request.auth.uid == resource.data.mentee_uid
          );
        }
        
        function willBeMeetingParticipant() {
          return isAuthenticated() && (
            request.auth.uid == request.resource.data.mentor_uid ||
            request.auth.uid == request.resource.data.mentee_uid
          );
        }
        
        // Read: Any authenticated user in university can view meetings
        allow read: if isInUniversity(universityPath);
        
        // Create: Mentor, mentee, or coordinator can create meetings
        allow create: if isInUniversity(universityPath) && (
          willBeMeetingParticipant() ||
          hasRole('coordinator')
        );
        
        // Update: Only participants or coordinator can update
        allow update: if isInUniversity(universityPath) && (
          isMeetingParticipant() ||
          hasRole('coordinator')
        );
        
        // Delete: Only coordinator (prefer soft delete via status)
        allow delete: if isInUniversity(universityPath) && hasRole('coordinator');
      }
      
      // Availability collection (NEW - moved from user subcollection)
      match /availability/{availabilityId} {
        function isMentorOwner() {
          return isAuthenticated() && request.auth.uid == resource.data.mentor_uid;
        }
        
        function willBeMentorOwner() {
          return isAuthenticated() && request.auth.uid == request.resource.data.mentor_uid;
        }
        
        // Read: Anyone in university can view availability
        allow read: if isInUniversity(universityPath);
        
        // Create: Only mentors can create their own availability
        allow create: if isInUniversity(universityPath) && 
          hasRole('mentor') &&
          willBeMentorOwner();
        
        // Update: Mentor owns it, or mentee booking it, or coordinator
        allow update: if isInUniversity(universityPath) && (
          isMentorOwner() ||
          (hasRole('mentee') && !resource.data.is_booked && request.resource.data.is_booked) ||
          hasRole('coordinator')
        );
        
        // Delete: Only mentor can delete their own unbooked availability
        allow delete: if isInUniversity(universityPath) && 
          isMentorOwner() &&
          !resource.data.is_booked;
      }
      
      // Announcements collection
      match /announcements/{announcementId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Mentorships collection
      match /mentorships/{mentorshipId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Progress Reports collection
      match /progress_reports/{reportId} {
        allow read: if isInUniversity(universityPath) && (
          request.auth.uid == resource.data.mentee_id ||
          request.auth.uid == resource.data.mentor_id ||
          hasRole('coordinator') ||
          hasRole('developer')
        );
        allow write: if isInUniversity(universityPath) && (
          request.auth.uid == resource.data.mentor_id ||
          hasRole('coordinator') ||
          hasRole('developer')
        );
      }
      
      // Events collection
      match /events/{eventId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Resources collection
      match /resources/{resourceId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('mentor') ||
          hasRole('developer')
        );
      }
      
      // Checklists collection
      match /checklists/{checklistId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('mentor') ||
          hasRole('developer')
        );
      }
      
      // Newsletters collection
      match /newsletters/{newsletterId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Notifications collection
      match /notifications/{notificationId} {
        allow read: if isInUniversity(universityPath) && 
          request.auth.uid == resource.data.userId;
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Mentee Goals collection
      match /mentee_goals/{goalId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('mentor') ||
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Action Items collection
      match /action_items/{itemId} {
        allow read: if isInUniversity(universityPath);
        allow write: if isInUniversity(universityPath) && (
          hasRole('mentor') ||
          hasRole('coordinator') || 
          hasRole('developer')
        );
      }
      
      // Catch-all for other collections at the data level
      match /{collection}/{document} {
        allow read: if isInUniversity(universityPath) && 
          collection != 'users' && 
          collection != 'conversations' && 
          collection != 'meetings' && 
          collection != 'availability' &&
          collection != 'announcements' &&
          collection != 'mentorships' &&
          collection != 'progress_reports' &&
          collection != 'events' &&
          collection != 'resources' &&
          collection != 'checklists' &&
          collection != 'newsletters' &&
          collection != 'notifications' &&
          collection != 'mentee_goals' &&
          collection != 'action_items';
        allow write: if isInUniversity(universityPath) && (
          hasRole('coordinator') || 
          hasRole('developer')
        ) &&
          collection != 'users' && 
          collection != 'conversations' && 
          collection != 'meetings' && 
          collection != 'availability' &&
          collection != 'announcements' &&
          collection != 'mentorships' &&
          collection != 'progress_reports' &&
          collection != 'events' &&
          collection != 'resources' &&
          collection != 'checklists' &&
          collection != 'newsletters' &&
          collection != 'notifications' &&
          collection != 'mentee_goals' &&
          collection != 'action_items';
      }
    }
    
    // University settings
    match /{universityPath}/settings {
      allow read: if isInUniversity(universityPath);
      allow write: if isInUniversity(universityPath) && (
        hasRole('coordinator') || 
        hasRole('developer')
      );
    }
    
    // Development/Testing override - REMOVE IN PRODUCTION
    // TODO: Comment out the line below before deploying to production
    match /{document=**} { allow read, write: if true; }
  }
}